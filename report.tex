\documentclass[]{article}
\usepackage{listings}

%opening
\title{Optimization of Prime Numbers Factoring}
\author{
	Dong Hyun Kim\\
\texttt{3522704}
\and
Craig Beaman\\
\texttt{3510536}}

\begin{document}

\maketitle

\begin{abstract}
The report showcases the different run-times of two algorithms that have been developed for factorization of prime numbers. The algorithms have been executed on two different computers with different specifications. The algorithms that have been implemented are Fermat's factorization algorithm and Trial Division algorithm. The report will also analyze each two different specifications and algorithms on how the algorithm changes run-time of prime factorization. 
\end{abstract}

\section{Introduction}
There are numerous algorithms that have been developed on prime number factorization over centuries. Some of the algorithms include Dixon's algorithm, Trial Division, Fermat's Factorization, Pollard's rho, and Euler's Factorization algorithm. Algorithms such as Trial Division are often very simple but has one of the longest run-time of all the algorithms.
\section{Trial Division}
Trial division is one of the most simplest algorithm on implementing factorization of prime numbers. However it has the worst run-time of all the factoring algorithm as it has time complexity of: $n\times \sqrt{n}/ln(n^2)$
\subsection{Code implementation}
The code implementation can be done in few lines. We use the factor 2 as the first possible factor. Using 2, we must divide the number with the factor variable. If it does not have any remainders, append the factor number to the list of prime numbers. Keep doing it until the number is no bigger than 1. Return the list when done.
\\ 
\begin{lstlisting}[language=Java]
def trial_division(n: int) ->List[int]:
	a=[]
	f=2
	while n>1:
		if n%f==0:
			a.append(f)
			n/=f
		else:
			f+=1
	return a
\end{lstlisting}
As seen from the code, this algorithm is works well for small numbers but once the number gets significantly large, the run-time gets significantly longer.
\section{Fermat's Factorization}
Fermat's Factorization method is based on the representation of an odd integer as the difference of two squares. For an integer $n$, we want $a$ and $b$ such as: $n=a^2-b^2=(a+b)(a-b)$ where $(a+b)$ and $(a-b)$ are the factors of the number $n$
\subsection{Code implementation}
\begin{lstlisting}[basicstyle=\small]
class GFG  
{ 
    static void FermatFactors(int n) 
    { 
         if(n <= 0) 
         { 
              System.out.print("["+ n + "]"); 
              return; 
         } 
         if((n & 1) == 0) 
         { 
             System.out.print("[" + n / 2.0 + "," + 2 + "]");  
             return; 
         } 
         int a = (int)Math.ceil(Math.sqrt(n)) ;  
         if(a * a == n)
         { 
             System.out.print("[" + a + "," + a + "]");  
             return; 	
         } 
         int b; 
         while(true) 
         { 
             int b1 = a * a - n ; 
             b = (int)(Math.sqrt(b1)) ; 
             if(b * b == b1) 
             break; 
         else
             a += 1; 
         } 
         System.out.print("[" + (a - b) +"," + (a + b) + "]" );  
         return; 
     }
 }
\end{lstlisting}
If $n=pq$ is a factorization of $n$ into two positive integers. Then since $n$ is odd so $p$ and $q$ are both odd. Let $a=\frac{1}{2}\times(p+q)$ and $b=\frac{1}{2}\times(q-p)$. Since $a$ and $b$ are both integers, then $p=(a-b)$ and $q=(a+b)$. So $n=pq=(a-b)(a+b)=a^2-b^2$. In case of prime number, we go back until $b=1$ in as one factor is 1 for prime number. A while loop ensures this operation. 
\section{Run-time and Analysis}
The $Driver.java$ allows the user set the minimum and maximum random prime number via changing the values of \lstinline|MIN_PRIME_VAL| and \lstinline|MAX_PRIME_VAL|. The variable \lstinline|NUM_OF_TESTS| will change number of random prime number between the minimum and maximum values. There is also an option to use a seed for the \lstinline|randomGenerator|.
\subsection{Specification and Run-times}
Specification of the machine are important aspect of the test as it could alter the run-time of the 2 algorithms. The two machines that have been tested are as follows:
\begin{itemize}
	\item Nvidia GeForce 940MX 2GB VRAM, Intel Core i5-7200U @ 3.1GHz
	\item Nvidia GeForce 1070 8GB VRAM, Intel Core i5-3570K @ 4.1GHz OC
\end{itemize}
We have ran the test on each machine with 3 different variable values. We have used the same seed 12345678 for the \lstinline|randomGenerator|.
\begin{itemize}
	\item Test1: Number of tests = 10, minimum value = 5, max value = 10000000
	\item Test2: Number of tests = 100, minimum value = 98000, max value = 100000
	\item Test3: Number of tests = 100, minimum value = 5, max value = 100000
\end{itemize}
Next page shows the average for each of the tests on Trial and Fermat algorithms. The values are in seconds.

\begin{table}[]
	\begin{tabular}{llll}
		& Test1 Avg(sec)  & Test2 Avg(sec)  & Test3 Avg(sec)  \\
		PC1 Trial  & 0.02021962 & 0.00685432 & 0.48980418 \\
		PC1 Fermat & 0.28818518 & 0.28818518 & 20.1220491 \\
		PC2 Trial  & 0.0198812  & 0.0058421  & 0.3921651  \\
		PC2 Fermat & 0.1991548  & 0.2004981  & 17.168416 
	\end{tabular}
\end{table}

\end{document}
